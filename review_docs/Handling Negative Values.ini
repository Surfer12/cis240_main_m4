
Handling Negative Values
	•	In decimal_to_binary, we detect if the input is negative and convert its absolute value to binary, then prepend a “-” sign.
	•	In binary_to_decimal, we similarly detect if the string starts with “-”, remove that sign for the internal conversion, and then reapply the negative sign to the final result.

	Overall, yes—the approach of checking for negativity first, stripping the sign, converting the absolute value, and then reattaching the sign is a valid sign-magnitude method. It cleanly handles floating-point numbers as well, so for educational or demonstration purposes, it’s entirely reasonable.

However, bear in mind a couple of nuances:
	1.	Sign-Magnitude vs. Two’s Complement
	•	If you were implementing binary representation in an actual machine-level context (like storing negative integers in memory), you would more commonly use two’s complement for negative values. That means the negative number’s binary form is not simply a - sign plus bits; it’s the inverted bits of the absolute value plus one. But for demonstration or “human-readable” binary output, simply adding a - sign is perfectly acceptable.
	2.	Consistency in Parsing
	•	Since you’re outputting negative binaries as "-1011.01", your binary_to_decimal function must be prepared to handle that sign, which you are doing by checking binary_num.startswith("-"), stripping the sign, and then reapplying it to the final result. This consistency ensures round-tripping works (decimal→binary→decimal) for both positive and negative values.
	3.	Floating-Point Caveats
	•	With floats, binary fractional parts often cannot be represented exactly. For instance, 0.1 in decimal is an infinitely repeating fraction in binary. You mitigate this in decimal_to_binary by limiting the fractional bits to 32. Just realize that if you round-trip (decimal→binary→decimal) you may see slight floating-point discrepancies—it’s normal in most floating-point systems.

In summary, using sign-magnitude with a separate flag for negative values is a fine, straightforward approach for demonstration or simple usage scenarios. If your goal is to model real computer data storage of negative numbers (especially integers), then you would look into two’s complement or other fixed-point/binary fraction formats.